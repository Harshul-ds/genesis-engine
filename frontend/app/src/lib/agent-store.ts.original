      autonomousStatus: '',
    });
  }
});
// src/lib/agent-store.ts
import { create } from 'zustand';
import { AppData, Step, ApiModel, PromptComponent, GeneratedPrompt, AgentStreamEvent } from './types';

// =========================================================================
// THE CORRECT PARSING LOGIC
// This is a helper function that correctly decodes the Vercel AI SDK stream format.
// =========================================================================
const parseAIStreamChunk = (chunk: string): string => {
  return chunk
    .split('\n') // A single chunk can have multiple lines
    .filter(line => line.startsWith('0:')) // We only care for the data lines
    .map(line => {
      try {
        // Remove the '0:' prefix and then JSON.parse the rest of the string
        // This correctly handles escaped characters like \" and \n
        return JSON.parse(line.substring(2));
      } catch (e) {
        return ''; // Ignore any malformed lines
      }
    })
    .join(''); // Join the clean text from all lines in the chunk
};

// ==============================================================================
// 1. STATE DEFINITION (Adding live history)
// ==============================================================================
interface AgentState {
  // --- CORE WIZARD STATE ---
  currentStep: Step;
  isAppLoading: boolean;
  appData: AppData | null;
  agentError: string | null;

  // --- DYNAMIC DATA STATE ---
  models: ApiModel[];
  suggestedTopics: string[];

  // --- USER INPUT STATE ---
  topic: string;
  goal: string;
  selectedPersonas: string[];
  selectedModel: string;

  isLoadingGoals: boolean;
  isLoadingPersonas: boolean;
  isGenerating: boolean;

  // --- AI-GENERATED STATE ---
  suggestedGoals: string[];
  suggestedPersonas: PromptComponent[];
  finalPrompts: GeneratedPrompt[];

  // --- NEW FOR PHASE 5 ---
  liveHistory: AgentStreamEvent[];

  // --- NEW FOR AUTONOMOUS AGENT FEATURE ---
  isAutonomous: boolean;
  autonomousStatus: string,

  // --- SETTERS ---
  setTopic: (topic: string) => void;
  setGoal: (goal: string) => void;
  setSelectedModel: (modelId: string) => void;

  // --- WIZARD NAVIGATION & LOGIC ---
  handleTopicSubmit: () => Promise<void>;
  handleGoalSubmit: () => Promise<void>;
  togglePersonaSelection: (personaTerm: string) => void;
  handlePersonasSubmit: () => void;
  handleModelSubmit: () => void;

  // --- NEW ACTIONS for the sophisticated workflow ---
  generateThoughts: () => Promise<void>;
  setAgentThoughts: (thoughts: string) => void;
  generateFinalPrompt: () => Promise<void>;

  // --- NEW FOR AUTONOMOUS AGENT FEATURE ---
  runAutonomousWorkflow: (initialTopic: string) => Promise<void>;

  reset: () => void;
}

// ==============================================================================
// 3. STORE CREATION
// Combining state and actions into the final Zustand store.
// ==============================================================================
export const useAgentStore = create<AgentState & AgentActions>((set, get) => ({
  // --- INITIAL STATE VALUES (Adding liveHistory) ---
  currentStep: 'topic',
  isAppLoading: true,
  appData: null,
  agentError: null,
  models: [],
  suggestedTopics: [],
  topic: '',
  goal: '',
  selectedPersonas: [],
  selectedModel: '',
  isLoadingTopics: false,
  isLoadingGoals: false,
  isLoadingPersonas: false,
  isGenerating: false,
  suggestedGoals: [],
  suggestedPersonas: [],
  finalPrompts: [],
  // --- NEW FOR AUTONOMOUS AGENT FEATURE ---
  isAutonomous: false,
  autonomousStatus: '',

  // --- ACTION IMPLEMENTATIONS ---

  /**
   * Initializes the application. Fetches DYNAMIC models and topic suggestions.
   */
  initializeApp: async (appData: AppData) => {
    try {
      set({ isAppLoading: true, appData, agentError: null, isLoadingTopics: true });

      const [modelsResponse, topicsResponse] = await Promise.all([
        fetch('/api/list-models'),
        fetch('/api/suggest-topics')
      ]);

      if (!modelsResponse.ok) throw new Error('Failed to fetch AI models.');
      if (!topicsResponse.ok) throw new Error('Failed to fetch initial topic suggestions.');

      const modelData: ApiModel[] = await modelsResponse.json();
      const topicData = await topicsResponse.json();

      const defaultModelId = modelData.length > 0 ? modelData[0].id : '';

      set({
        models: modelData,
        selectedModel: defaultModelId,
        suggestedTopics: topicData,
        isAppLoading: false,
        isLoadingTopics: false
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
      console.error("App initialization failed:", errorMessage);
      set({
        isAppLoading: false,
        isLoadingTopics: false,
        agentError: `Could not initialize application: ${errorMessage}`,
        suggestedTopics: [
          'Sustainable fashion and eco-friendly textiles',
          'AI-powered personal finance management',
          'Remote work productivity tools',
          'Mental health and wellness apps',
          'Blockchain applications in supply chain',
          'Renewable energy storage solutions',
          'Autonomous vehicle safety systems',
          'Personalized learning platforms'
        ]
      });
    }
  },

  /**
   * Updates the topic in the state as the user types.
   */
  setTopic: (topic: string) => {
    set({ topic });
  },

  /**
   * Updates the goal in the state.
   */
  setGoal: (goal: string) => {
    set({ goal });
  },

  /**
   * Updates the user's selected model in the state.
   */
  setSelectedModel: (modelId: string) => {
    set({ selectedModel: modelId });
  },

  /**
   * Handles the submission of the topic.
   * Calls the backend to get DYNAMIC goal suggestions.
   */
  handleTopicSubmit: async () => {
    const { topic } = get();
    if (!topic.trim()) return;

    set({ isLoadingGoals: true, agentError: null, suggestedGoals: [] });

    try {
      const response = await fetch('/api/suggest-goals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ topic }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to generate goals.');
      }

      const generatedGoals = await response.json();

      set({
        suggestedGoals: generatedGoals,
        isLoadingGoals: false,
        currentStep: 'goals'
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Failed to generate goals.";
      console.error("Goal suggestion failed:", errorMessage);
      set({ isLoadingGoals: false, agentError: errorMessage });
    }
  },

  /**
   * Handles the submission of goals and moves to personas step.
   */
  handleGoalSubmit: async () => {
    const { goal, appData } = get();
    if (!goal.trim()) return;

    set({ isLoadingPersonas: true, agentError: null });

    try {
      // Generate persona suggestions based on topic and goal
      if (appData) {
        // For now, use all available personas as suggestions
        // In the future, this could be more intelligent
        const personaSuggestions = appData.personas.map((persona: PromptComponent, index: number) => ({
          id: persona.id || index, // Use existing id or generate one
          term: persona.term,
          description: persona.description,
          content: persona.content,
          component_type: persona.component_type
        }));

        set({
          suggestedPersonas: personaSuggestions,
          isLoadingPersonas: false,
          currentStep: 'personas'
        });
      } else {
        throw new Error('App data not available');
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Failed to load personas.";
      console.error("Persona loading failed:", errorMessage);
      set({ isLoadingPersonas: false, agentError: errorMessage });
    }
  },

  /**
   * Adds or removes a persona from the user's selection.
   */
  togglePersonaSelection: (personaTerm: string) => {
    const { selectedPersonas } = get();
    const newSelection = selectedPersonas.includes(personaTerm)
      ? selectedPersonas.filter(p => p !== personaTerm) // Remove if exists
      : [...selectedPersonas, personaTerm]; // Add if doesn't exist
    set({ selectedPersonas: newSelection });
  },

  /**
   * Finalizes the persona selection and moves to the final configuration step.
   */
  handlePersonasSubmit: () => {
    const { selectedPersonas } = get();
    if (selectedPersonas.length === 0) {
      // You could show a toast or error here, but for now we just prevent moving on.
      console.warn("No personas selected. Please select at least one.");
      return;
    }
    set({ currentStep: 'model' });
  },

  /**
   * STEP 1: GENERATE INITIAL THOUGHTS
   */
  generateThoughts: async () => {
    const { selectedModel, topic, goal, selectedPersonas } = get();
    // We now go directly to the 'refinement' step, which will show the live stream.
    set({ currentStep: 'refinement', agentError: null, agentThoughts: '' });

    try {
      const thoughtsPrompt = `
        As a world-class prompt engineer, think step-by-step about how to construct the best possible prompt.
        Lay out your reasoning, considerations, and the structure you will use. Do NOT generate the final prompt yet.
        The user's input is:
        - Topic: "${topic}"
        - Goals: ${goal}
        - Persona for the target AI: "${selectedPersonas[0]}"
      `;

      const response = await fetch('/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: selectedModel,
          history: [{ role: 'user', content: thoughtsPrompt }],
        }),
      });

      if (!response.ok || !response.body) throw new Error('API Error during thought generation.');

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      // ✨ KEY CHANGE: The UI state is updated INSIDE the loop ✨
      while (true) {
        const { done, value } = await reader.read();
        if (done) break; // Exit the loop when the stream is finished

        const decodedChunk = decoder.decode(value);
        const cleanText = parseAIStreamChunk(decodedChunk);

        // This updates the state with every new piece of text, triggering a live UI update.
        set((state) => ({ agentThoughts: state.agentThoughts + cleanText }));
      }
      // No need to do anything after the loop finishes. The UI is already up to date.

    } catch (error: any) {
      set({ agentError: error.message, currentStep: 'model' });
    }
  },

  /**
   * ✨ RENAMED ACTION: This is now clearer.
   */
  setAgentThoughts: (thoughts: string) => set({ agentThoughts: thoughts }),
  /**
   * STEP 2: GENERATE THE FINAL PROMPT USING THE REFINED THOUGHTS
   */
  generateFinalPrompt: async () => {
    const { selectedModel, topic, goal, selectedPersonas, agentThoughts } = get();
    // Go back to 'generating' for the final prompt creation
    set({ currentStep: 'generating', agentError: null, generationResult: '' });

    try {
      // This prompt uses the (potentially edited) thoughts to create the final prompt.
      const finalPromptInstruction = `
        Using the following thought process as your guide:
        ---THOUGHTS---
        ${agentThoughts}
        ---
        Now, generate the final, copy-pasteable prompt in Markdown format based on these thoughts and the original user request:
        - Topic: "${topic}"
        - Goals: ${goal}
        - Persona for the target AI: "${selectedPersonas[0]}"
      `;

      const response = await fetch('/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: selectedModel,
          history: [{ role: 'user', content: finalPromptInstruction }],
        }),
      });

      if (!response.ok || !response.body) throw new Error('API Error during final prompt generation.');

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      // Also stream the final result for a great UX
      let fullPromptResponse = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const decodedChunk = decoder.decode(value);
        const cleanText = parseAIStreamChunk(decodedChunk);
        fullPromptResponse += cleanText;
        set((state) => ({ generationResult: state.generationResult + cleanText }));
      }

      set({ currentStep: 'results', generationResult: fullPromptResponse });

    } catch (error: any) {
      set({ agentError: error.message, currentStep: 'refinement' });
    }
  },

  // START ADDITION: The new orchestrator action for autonomous workflow
  runAutonomousWorkflow: async (initialTopic: string) => {
    // Ensure we don't run it twice
    if (get().isAutonomous) return;

    // A. Kick off the process
    set({
      isAutonomous: true,
      topic: initialTopic,
      autonomousStatus: 'Initializing Agent...',
      currentStep: 'topic',
    });

    const wait = (ms: number) => new Promise(res => setTimeout(res, ms));

    try {
      // B. Select Goals (reusing existing components and static data)
      await wait(1500);
      set({
        autonomousStatus: 'Selecting goals...',
        goal: 'Generate a comprehensive business plan', // Use a default goal since we don't have staticGoals
        currentStep: 'goals'
      });

      // C. Select Persona
      await wait(2000);
      const { appData } = get();
      if (appData && appData.personas.length > 0) {
        set({
          autonomousStatus: 'Choosing best persona...',
          selectedPersonas: [appData.personas[0].term], // Use first available persona
          currentStep: 'personas'
        });
      } else {
        throw new Error('No personas available');
      }

      // D. Select Model
      await wait(1500);
      const { models } = get();
      if (models.length > 0) {
        set({
          autonomousStatus: 'Selecting optimal model...',
          selectedModel: models[0].id, // Use first available model
          currentStep: 'model'
        });
      } else {
        throw new Error('No models available');
      }

      // E. Call the final generation function that already exists
      await wait(1000);
      set({ autonomousStatus: 'Preparing to generate...' });
      get().handleModelSubmit();

    } catch (error: any) {
      console.error("Autonomous agent failed:", error);
      set({ agentError: 'The autonomous agent failed.', isAutonomous: false });
    }
  },
  handleModelSubmit: () => {
    get().generateThoughts();
  },

  /**
   * Resets the entire wizard to its initial state for a new session.
   */
  reset: () => {
    set({
      currentStep: 'topic',
      isAppLoading: true,
      topic: '',
      goal: '',
      selectedPersonas: [],
      selectedModel: '',
      suggestedGoals: [],
      suggestedPersonas: [],
      finalPrompts: [],
      agentError: null,
      liveHistory: [], // Also clear history on reset
      agentThoughts: '',
      generationResult: '',
      isAutonomous: false,
